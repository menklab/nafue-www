var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Use a lookup table to find the index.
var lookup = new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}

function encodeAb(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
        i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
}

function decodeAb(base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
            bufferLength--;
        }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];

        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
}
function domInit() {
    return {
        preview: document.getElementById('preview'),
        dropZone: document.getElementById('dropZone'),
        list: document.getElementById('list'),
        file: document.getElementById('file'),
        password: document.getElementById('password'),
        passCont: document.getElementById('passCont'),
        busy: document.getElementById('busy'),
        showLink: document.getElementById('showLink'),
        linkToShare: document.getElementById('linkToShare'),
        busyMessage: document.getElementById('busyMessage'),
        share: document.getElementById("share"),
        downloadBtn: document.getElementById("downloadBtn"),
        reset: document.getElementById("reset"),
        doneDownloading: document.getElementById("doneDownloading"),
        unsupported: document.getElementById("unsupported"),
        badPass: document.getElementById("badPass"),
        error: document.getElementById("error"),
        errMsg: document.getElementById("errMsg"),
        paymentForm: document.getElementById("payment-form"),
        checkout_loading: document.getElementById("checkout_loading"),
        checkout_error: document.getElementById("checkout_error"),
        amount: document.getElementById("amount"),
        donate: document.getElementById("donate"),
        passwordStrength: document.getElementById("passwordStrength"),
        passwordSuggestions: document.getElementById("passwordSuggestions"),
        terrible: document.getElementById("terrible"),
        weak: document.getElementById("weak"),
        mediocre: document.getElementById("mediocre"),
        strong: document.getElementById("strong"),
        excellent: document.getElementById("excellent"),
        thanks: document.getElementById("thanks"),
        passwordStrengthBar: document.getElementById("passwordStrengthBar")

    };
}

function error(errMsg) {
    reset_ui();
    hide(dom.dropZone);
    show(dom.error);
    //resetPassword();
    g.binData = null;
    dom.errMsg.innerHTML = errMsg;
}

function badPassword() {
    show(dom.badPass);
    dom.password.value = "";
}

function reset_ui() {
    g = {};
    g.mode = "upload";
    dom.file.value = "";
    show(dom.dropZone);
    hide(dom.showLink);
    hide(dom.passCont);
    hide(dom.doneDownloading);
    hide(dom.busy);
    hide(dom.unsupported);
    hide(dom.error);
    hide(dom.badPass);
    hide(dom.passwordStrength);
    dom.share.disabled = true;
    resetPassword();
    g.binData = null;
    dom.file.focus();
}


function hide(e) {
    e.hidden = true;
}
function show(e) {
    e.hidden = false;
}
function setContent(e, c) {
    e.innerHTML = c;
}

function updatePasswordStrength(results) {
    var s = 0;
    if (!!results && !!results.score) {
        s = results.score; // score
    }

    // enable button if password has value
    if (!!dom.password.value) {
        dom.share.disabled = false;
    }
    else {
        dom.share.disabled = true;
    }

    // calculate percent
    var perc = ((s + 1)/5) * 100;
    if (!dom.password.value || dom.password.value === '') {
        perc = 0;
    }

    setBarPercent(dom.passwordStrengthBar, perc);
}

/*
 * http module for making ajax requests
 * methods:
 * http.get('url')
 */
var api_services = "http://localhost:9090";
var www_services = "http://localhost:8080";

var http = (function () {

    var parse = function (req) {
        var result;
        try {
            result = JSON.parse(req.responseText);
        } catch (e) {
            result = req.responseText;
        }
        return result;
    };

    function ajx(method, url, data, config) {
        var methods = {
            success: function () {
            },
            error: function () {
            }
        };

        var XHR = window.XMLHttpRequest || ActiveXObject;
        var request = new XHR('MSXML2.XMLHTTP.3.0');
        request.open(method, url, true);
        if (typeof config.contentType === 'undefined') {
            request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        }
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status >= 200 && request.status < 300) {
                    methods.success(parse(request));
                } else {
                    methods.error(parse(request));
                }
            }
        };
        request.send(data);
        var callbacks = {
            success: function (callback) {
                methods.success = callback;
                return callbacks;
            },
            error: function (callback) {
                methods.error = callback;
                return callbacks;
            }
        };
        return callbacks;
    }


    return {
        get: function (url, data, config) {
            config = config || {};
            return ajx('GET', url, data, config);
        },
        post: function (url, data, config) {
            config = config || {};
            return ajx('POST', url, data, config);
        },
        put: function (url, data, config) {
            config = config || {};
            return ajx('PUT', url, data, config);
        },
        'delete': function (url, data, config) {
            config = config || {};
            return ajx('DELETE', url, data, config);
        }
    };
})();
var dom, modal, g, s = {
    adata: "",
    mode: 'ccm',
    cipher: 'aes',
    tagSize: 128,
    keySize: 256,
    iterations: 1000
};


function init() {

    dom = domInit();
    modal = modalInit();
    g = {
        mode: "upload",
        db: {},
        binData: null
    };

    if (window.File && window.FileReader && window.FileList && window.Blob && window.indexedDB) {

        // init file store
        dbInit(function(db) {
            // create db handles
            g.db['headers'] = function() {
                return db.transaction(["fileHeaders"], "readwrite").objectStore("fileHeaders");
            };
            g.db['chunks'] = function() {
                return db.transaction(["fileChunks"], "readwrite").objectStore("fileChunks");
            };

            // check for decryption file
            var dFile;
            var parse = parseURL(window.location.href);
            if (parse.pathname[1] == "file") {
                dFile = parse.pathname[2];
            }
            if (!!dFile) {
                window.history.pushState('', '', '/');
                downloadFile(dFile);
            }

            if (!!dom.dropZone) {
                dom.dropZone.addEventListener('dragover', handleDragOver, false);
                dom.dropZone.addEventListener('drop', handleFileSelect, false);
            }
            if (!!dom.file) {
                dom.file.addEventListener('change', handleFileSelect, false);
                dom.file.focus();
            }
            // setup password check listener
            window.onload = function () {
                if (!!dom.password) {
                    dom.password.onkeyup = function () {
                        updatePasswordStrength(zxcvbn(dom.password.value));
                    };
                }
            };
        });


    }
    else {
        hide(dom.dropZone);
        show(dom.unsupported);
    }

}

function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

init();




function modalInit() {
    var modal = document.getElementById('modal');
    var content = document.getElementById('modal-content');
    var background = document.getElementById('modal-background');
    var bt;

    function hide_modal() {
        setTimeout(function () {
            if (!!bt) {
                bt.teardown(function () {
                    bt = null;
                });
            }
            //dom.paymentForm.innerHTML = null;
            dom.paymentForm.style.height = "0";
            dom.paymentForm.style.opacity = "0";
            hide(dom.amount);
            hide(dom.donate);
            show(dom.checkout_loading);
            hide(dom.thanks);
            hide(dom.checkout_error);
            modal.hidden = true;
        }, 0);
    }

    function show_modal() {
        setTimeout(function () {
            modal.hidden = false;

            // init payment stuff
            http.get(api_services + "/api/payment")
                .success(function (data) {
                    show(dom.paymentForm);
                    var clientToken = data.token;
                    braintree.setup(clientToken, "dropin", {
                        container: "payment-form",
                        onReady: function (integration) {
                            bt = integration;
                            hide(dom.checkout_loading);
                            show(dom.amount);
                            show(dom.donate);
                            dom.paymentForm.style.height = "auto";
                            dom.paymentForm.style.opacity = "100";
                        },
                        onPaymentMethodReceived: function (payload) {
                            payload.amount = dom.amount.value;
                            dom.amount.value = null;
                            hide(dom.amount);
                            hide(dom.donate);
                            show(dom.checkout_loading);
                            dom.paymentForm.style.height = "0";
                            dom.paymentForm.style.opacity = "0";
                            http.post(api_services + "/api/payment", JSON.stringify(payload))
                                .success(function (res) {
                                    hide(dom.checkout_loading);
                                    show(dom.thanks);
                                })
                                .error(function (err) {
                                    show(dom.checkout_error);
                                    hide(dom.checkout_loading);
                                });
                        }
                    });
                })
                .error(function (e) {
                    show(dom.checkout_error);
                    hide(dom.checkout_loading);
                });
        }, 0);
    }

    // register onClick of background
    if (!!background) {
        background.addEventListener("click", function (e) {
            if (e.target.id === 'modal-background' && !document.getElementById('modal-background').hidden) {
                hide_modal();
            }
        });
    }

    // register escape key
    window.addEventListener("keyup", function (e) {
        if (!modal.hidden && e.keyCode == 27) {
            hide_modal();
        }
    }, false);

    function getToken() {
        // init payment stuff
        http.get(api_services + "/api/clientToken")
            .success(function (data) {
                show(dom.paymentForm);
                hide(dom.checkout_loading);
                var clientToken = data.token;
                braintree.setup(clientToken, "dropin", {
                    container: "payment-form"
                });
            })
            .error(function (e) {
                show(dom.checkout_error);
                hide(dom.checkout_loading);
            });
    }

    if (!!dom.amount) {
        dom.amount.addEventListener('blur', function () {
            if (this.value === '') {
                return;
            }
            this.setAttribute('type', 'text');
            if (this.value.indexOf('.') === -1) {
                this.value = this.value + '.00';
            }
            if (this.value.indexOf('.') === 0) {
                this.value = '1.00';
            }
            while (this.value.indexOf('.') > this.value.length - 3) {
                this.value = this.value + '0';
            }
        });
        dom.amount.addEventListener('focus', function () {
            this.setAttribute('type', 'number');
        });
    }

    return {
        show: show_modal,
        hide: hide_modal,
        getToken: getToken
    };


}


// on browser resize...
$(window).resize(function () {
    moveProgressBar();
});

// SIGNATURE PROGRESS
function moveProgressBar() {
    var getPercent = ($('.progress-wrap').data('progress-percent') / 100);
    var getProgressWrapWidth = $('.progress-wrap').width();
    var progressTotal = getPercent * getProgressWrapWidth;
    var animationLength = 100;

    // on page load, animate percentage bar to data percentage length
    // .stop() used to prevent animation queueing
    $('.progress-bar').stop().animate({
        left: progressTotal
    }, animationLength);
}

function setBarPercent(obj, percent) {
    $('#passwordStrengthBar').data('progress-percent', percent);
    moveProgressBar();
}

class FileHeader {

    constructor(prop) {
        this.name = prop.name;
        this.nameAry = this.getNameAry();
        this.fileSize = prop.size;
        this.secureFileSize = this.getTotalSecuredSize();
    }

    getTotalSecuredSize() {
        var t = this.fileSize;
        t += Crypt.config().KEY_SIZE;
        t += this.getNameAry().length;
        return t;
    }

    getNameAry() {
        return Utility.bytesToUint8(this.name);
    }
}
class Crypt {

    static config() {
        return {
            ITERATIONS: 1000,
            KEY_SIZE: 32
        };
    }

    // create cipher
    constructor(prop) {

        this.salt = prop.salt || Crypt.makeSalt();
        this.iv = prop.iv || Crypt.makeIv();
        this.key = Crypt.genPbkdf2Key(prop.password, this.salt);
        this.cipher = forge.cipher.createCipher('AES-CTR', this.key);
        this.cipher.start({iv: this.iv});
        this.hmac = forge.hmac.create();
        this.hmac.start('sha256', this.key);
    }

    // secure destroy cipher
    destroy() {
        this.cipher.finish();
        delete this.salt;
        delete this.iv;
        delete this.key;
        delete this.cipher;
        var h = this.hmac.digest().toHex();
        delete this.hmac;
        return h;
    }

    // xor encrypt/decrypt in Uint8Array
    xorUintAry(data) {
        this.cipher.update(new forge.util.ByteBuffer(data));
    }

    // make an iv
    static makeIv() {
        return forge.random.getBytesSync(Crypt.config().KEY_SIZE);
    }

    // make salt
    static makeSalt() {
        return forge.random.getBytesSync(Crypt.config().KEY_SIZE);
    }

    // gen a key
    static genPbkdf2Key(password, salt) {
        return forge.pkcs5.pbkdf2(password, salt, Crypt.config().ITERATIONS, Crypt.config().KEY_SIZE);
    }

}





function handleFileSelect(e) {
    setContent(dom.busyMessage, "Processing");

    show(dom.busy);
    hide(dom.dropZone);
    e.stopPropagation();
    e.preventDefault();

    var files;
    if (!!e.dataTransfer && !!e.dataTransfer.files) {
        files = e.dataTransfer.files;
    }

    if (!!e.target && !!e.target.files) {
        files = e.target.files;
    }

    // only 1 file at a time
    if (files.length > 1) {
        error("Only 1 file at a time.");
        return;
    }

    var file = files[0];
    var secureFileChunker = new SecureFileChunker(file);
    secureFileChunker.checkSizeLimit();
    secureFileChunker.sealFile(function(tSize, hmac) {
        console.log("file sealed. OrigSize: " + file.size + ", tSize: " + tSize);
        console.log("hmac: ", hmac);
    });
}


function handleDragOver(e) {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
}

function downloadFile(file) {
    hide(dom.dropZone);
    show(dom.downloadBtn);
    setContent(dom.busyMessage, "Downloading");
    show(dom.busy);

    http.get(api_services + "/api/files/" + file)
        .success(function (res) {
            http.get(res.downloadUrl)
                .success(function (eData) {
                    res.ct = eData;
                    g.ct = {
                        ct: sjcl.codec.base64.toBits(eData),
                        p: {
                            hmac: sjcl.codec.base64.toBits(res.hmac),
                            salt: sjcl.codec.base64.toBits(res.salt)
                        }
                    };

                    // move to decrypt
                    decryptScreen();
                })
                .error(function (err) {
                    error("The file could not be access or no longer exists.");
                });
        })
        .error(function (err) {
            error("The file could not be access or no longer exists.");
        });
}

function shareFile() {
    hide(dom.passCont);
    show(dom.busy);

    // do encryption
    setContent(dom.busyMessage, "Encrypting");
    var ct = doEncrypt(dom.password.value, sjcl.codec.base64.toBits(g.binData));
    // make api request for saving file
    var payload = {
        iv: sjcl.codec.base64.fromBits(ct.p.iv),
        salt: sjcl.codec.base64.fromBits(ct.p.salt),
        aData: sjcl.codec.base64.fromBits(ct.p.adata)
    };
    console.log("salt: ", ct.p.salt);
    console.log("salt b64: ", sjcl.codec.base64.fromBits(ct.p.salt));
    console.log("iv: ", ct.p.iv);
    console.log("iv b64: ", sjcl.codec.base64.fromBits(ct.p.iv));


    // make upload request
    request = JSON.stringify(payload);
    http.post(api_services + "/api/files", request)
        .success(function (fileData) {
            setTimeout(function () {
                setContent(dom.busyMessage.innerHTML, "Uploading");
                // do upload to aws s3
                var data = sjcl.codec.base64.fromBits(ct.ct);
                http.put(fileData.uploadUrl, data, {contentType: "text/plain;charset=UTF-8"})
                    .success(function (res) {
                        hide(dom.busy);
                        show(dom.showLink);
                        setContent(dom.linkToShare, www_services + "/file/" + fileData.shortUrl);
                    })
                    .error(function (err) {
                        error(err.message);
                    });
            }, 500);

        })
        .error(function (err) {
            error(err.message);
        });
}

function decryptScreen() {
    g.mode = "download";
    hide(dom.busy);
    show(dom.passCont);
    hide(dom.share);
    show(dom.downloadBtn);
    dom.password.focus();
}

function decryptFile() {
    var data = JSON.parse(atob(sjcl.codec.base64.fromBits(doDecrypt(dom.password.value, g.ct))));
    var blob = new Blob([decodeAb(data.content)], {type: "application/json"});

    saveAs(blob, data.name);

    show(dom.doneDownloading);
    hide(dom.passCont);
    setTimeout(function () {
        hide(dom.doneDownloading);
        reset_ui();
    }, 1000 * 10);
}

function dbInit(cb) {
    var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
    var db;
// Open (or create) the database
    var req = indexedDB.open("www.nafue.com", 1);

// Create the schema
    req.onupgradeneeded = function (evt) {
        evt.currentTarget.result.createObjectStore("fileHeaders", {autoIncrement: true});
        var chunkStore = evt.currentTarget.result.createObjectStore("fileChunks", {autoIncrement: true});
        chunkStore.createIndex("fileChunks", "fileHeaderId", {unique: false});

    };

    req.onsuccess = function () {
        db = this.result;
        cb(db)
    };
}
function parseURL(url) {
    var parser = document.createElement('a'),
        searchObject = {},
        queries, split, i;
    // Let the browser do the work
    parser.href = url;
    // Convert query string to object
    queries = parser.search.replace(/^\?/, '').split('&');
    for (i = 0; i < queries.length; i++) {
        split = queries[i].split('=');
        searchObject[split[0]] = split[1];
    }
    return {
        protocol: parser.protocol,
        host: parser.host,
        hostname: parser.hostname,
        port: parser.port,
        pathname: parser.pathname.split("/"),
        search: parser.search,
        searchObject: searchObject,
        hash: parser.hash
    };
}
class SecureFileChunker {

    static config() {
        return {
            fileSizeLimit: 1024 * 1024 * 50, // 50mb
            chunkSize: 3200 // 32kb
        }
    }

    constructor(prop) {
        this.file = prop;
        this.fileHeader = new FileHeader(this.file);
        this.reader = new FileReader();
        this.crypt = new Crypt({password: 'password'});


    }

    sealFile(cb) {
        var me = this;

        // calc total chunks
        var tChunks = Math.ceil(me.fileHeader.secureFileSize / SecureFileChunker.config().chunkSize);

        // add fileHeader to indexddb
        var req = g.db.headers().add(me.fileHeader);
        req.onsuccess = function (event) {
            me.fileHeader.id = event.target.result;

            // read first chunk
            me.readChunk(me, tChunks, 0, 0, function (tSize) {
                var hmac = me.crypt.destroy();
                cb(tSize, hmac);
            });
        };


    }

    readChunk(me, tChunks, curChunk, tSize, cb) {
        // calc chunk start/end
        var start = SecureFileChunker.config().chunkSize * curChunk;
        var end = (SecureFileChunker.config().chunkSize * curChunk) + SecureFileChunker.config().chunkSize;
        if (curChunk == (tChunks - 1)) { // if on last chunk end == last byte
            end = me.fileHeader.secureFileSize;
        }
        me.reader.onloadend = function (evt) {
            if (evt.target.readyState == FileReader.DONE) {

                // get data from read
                var buffer = evt.target.result;
                var data = new Uint8Array(buffer);

                // encrypt data from read
                me.crypt.cipher.update(new forge.util.ByteBuffer(data));
                var eData = Utility.bytesToUint8(me.crypt.cipher.output.getBytes());
                var addedChunkEvt = g.db.chunks().add(
                    {
                        fileHeaderId: me.fileHeader.id,
                        data: eData
                    }
                );

                addedChunkEvt.onsuccess = function () {
                    // sum data as it's added
                    tSize += eData.length;
                    me.crypt.hmac.update(eData);

                    // if there are more chunks read the next one
                    if (curChunk < tChunks) {
                        me.readChunk(me, tChunks, (curChunk + 1), tSize, cb);
                    }
                    // otherwise finish last block with extra data and close
                    else {
                        var paddedFileName = new Uint8Array(255);
                        paddedFileName.fill(0);
                        paddedFileName.set(me.fileHeader.nameAry);
                        me.crypt.cipher.update(new forge.util.ByteBuffer(paddedFileName));
                        eData = Utility.bytesToUint8(me.crypt.cipher.output.getBytes());

                        // take encrypted filename data and add the iv to it.
                        var eiData = new Uint8Array((255 + Crypt.config().KEY_SIZE));
                        eiData.set(eData);
                        var iv = Utility.bytesToUint8(me.crypt.iv);
                        eiData.set(iv, 255);
                        var addFinalChunkEvt = g.db.chunks().add(
                            {
                                fileHeaderId: me.fileHeader.id,
                                data: eiData
                            }
                        );

                        addFinalChunkEvt.onsuccess = function() {
                            me.crypt.hmac.update(eiData);
                            cb(tSize + eiData.length);
                        };
                    }
                };
            }
        };
       // do read
        var chunkToRead = me.file.slice(start, end);
        me.reader.readAsArrayBuffer(chunkToRead);
    }

    checkSizeLimit() {
        if (this.fileHeader.fileSize / 1024 / 1024 > 50) {
            this.reader.abort();
            error('The uploaded file cannot be greater than 50MB');
        }
    }
}

class Utility {

    static uint8ToBytes(buf) {
        return String.fromCharCode.apply(null, buf)
    }

    static bytesToUint8(buf) {
        var u8 = new Uint8Array(buf.split("").map(function (c) {
            return c.charCodeAt(0);
        }));
        return u8;
    }

}
//# sourceMappingURL=../maps/app.min.js.map